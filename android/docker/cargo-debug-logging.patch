commit dd61c79e0e8e846de288a59e3c1d4c803beaf2b8
Author: Kalle Lindstr√∂m <karl.lindstrom@mullvad.net>
Date:   Fri Jan 17 11:21:29 2025 +0100

    Add debug hash logging

diff --git a/src/cargo/core/compiler/build_runner/compilation_files.rs b/src/cargo/core/compiler/build_runner/compilation_files.rs
index d8199c726..bd773dac5 100644
--- a/src/cargo/core/compiler/build_runner/compilation_files.rs
+++ b/src/cargo/core/compiler/build_runner/compilation_files.rs
@@ -590,7 +590,7 @@ fn compute_metadata(
     let bcx = &build_runner.bcx;
     let mut hasher = StableHasher::new();
 
-    METADATA_VERSION.hash(&mut hasher);
+    dbg!(METADATA_VERSION).hash(&mut hasher);
 
     // Unique metadata per (name, source, version) triple. This'll allow us
     // to pull crates from anywhere without worrying about conflicts.
@@ -601,35 +601,35 @@ fn compute_metadata(
 
     // Also mix in enabled features to our metadata. This'll ensure that
     // when changing feature sets each lib is separately cached.
-    unit.features.hash(&mut hasher);
+    dbg!(&unit.features).hash(&mut hasher);
 
     // Mix in the target-metadata of all the dependencies of this target.
     let mut deps_metadata = build_runner
         .unit_deps(unit)
         .iter()
-        .map(|dep| metadata_of(&dep.unit, build_runner, metas).meta_hash)
+        .map(|dep| dbg!(metadata_of(&dep.unit, build_runner, metas)).meta_hash)
         .collect::<Vec<_>>();
     deps_metadata.sort();
-    deps_metadata.hash(&mut hasher);
+    dbg!(deps_metadata).hash(&mut hasher);
 
     // Throw in the profile we're compiling with. This helps caching
     // `panic=abort` and `panic=unwind` artifacts, additionally with various
     // settings like debuginfo and whatnot.
-    unit.profile.hash(&mut hasher);
-    unit.mode.hash(&mut hasher);
-    build_runner.lto[unit].hash(&mut hasher);
+    dbg!(&unit.profile).hash(&mut hasher);
+    dbg!(unit.mode).hash(&mut hasher);
+    dbg!(build_runner.lto[unit]).hash(&mut hasher);
 
     // Artifacts compiled for the host should have a different
     // metadata piece than those compiled for the target, so make sure
     // we throw in the unit's `kind` as well.  Use `fingerprint_hash`
     // so that the StableHash doesn't change based on the pathnames
     // of the custom target JSON spec files.
-    unit.kind.fingerprint_hash().hash(&mut hasher);
+    dbg!(unit.kind.fingerprint_hash()).hash(&mut hasher);
 
     // Finally throw in the target name/kind. This ensures that concurrent
     // compiles of targets in the same crate don't collide.
-    unit.target.name().hash(&mut hasher);
-    unit.target.kind().hash(&mut hasher);
+    dbg!(unit.target.name()).hash(&mut hasher);
+    dbg!(unit.target.kind()).hash(&mut hasher);
 
     hash_rustc_version(bcx, &mut hasher, unit);
 
@@ -637,7 +637,7 @@ fn compute_metadata(
         // This is primarily here for clippy. This ensures that the clippy
         // artifacts are separate from the `check` ones.
         if let Some(path) = &build_runner.bcx.rustc().workspace_wrapper {
-            path.hash(&mut hasher);
+            dbg!(path).hash(&mut hasher);
         }
     }
 
@@ -648,7 +648,7 @@ fn compute_metadata(
         .gctx
         .get_env("__CARGO_DEFAULT_LIB_METADATA")
     {
-        channel.hash(&mut hasher);
+        dbg!(channel).hash(&mut hasher);
     }
 
     // std units need to be kept separate from user dependencies. std crates
@@ -658,7 +658,7 @@ fn compute_metadata(
     // don't need unstable support. A future experiment might be to set
     // `is_std` to false for build dependencies so that they can be shared
     // with user dependencies.
-    unit.is_std.hash(&mut hasher);
+    dbg!(unit.is_std).hash(&mut hasher);
 
     // While we don't hash RUSTFLAGS because it may contain absolute paths that
     // hurts reproducibility, we track whether a unit's RUSTFLAGS is from host
@@ -677,7 +677,7 @@ fn compute_metadata(
                 .target_config(CompileKind::Host)
                 .links_overrides
                 != unit.links_overrides;
-        target_configs_are_different.hash(&mut hasher);
+        dbg!(target_configs_are_different).hash(&mut hasher);
     }
 
     Metadata {
@@ -697,7 +697,7 @@ fn hash_rustc_version(bcx: &BuildContext<'_, '_>, hasher: &mut StableHasher, uni
         // regardless of the host.
         for line in bcx.rustc().verbose_version.lines() {
             if unit.kind.is_host() || !line.starts_with("host: ") {
-                line.hash(hasher);
+                dbg!(line).hash(hasher);
             }
         }
         return;
@@ -708,12 +708,12 @@ fn hash_rustc_version(bcx: &BuildContext<'_, '_>, hasher: &mut StableHasher, uni
     //
     // This assumes that the first segment is the important bit ("nightly",
     // "beta", "dev", etc.). Skip other parts like the `.3` in `-beta.3`.
-    vers.pre.split('.').next().hash(hasher);
+    dbg!(vers.pre.split('.').next()).hash(hasher);
     // Keep "host" since some people switch hosts to implicitly change
     // targets, (like gnu vs musl or gnu vs msvc). In the future, we may want
     // to consider hashing `unit.kind.short_name()` instead.
     if unit.kind.is_host() {
-        bcx.rustc().host.hash(hasher);
+        dbg!(bcx.rustc().host).hash(hasher);
     }
     // None of the other lines are important. Currently they are:
     // binary: rustc  <-- or "rustdoc"
diff --git a/src/cargo/core/package_id.rs b/src/cargo/core/package_id.rs
index 37b367218..2de7451d3 100644
--- a/src/cargo/core/package_id.rs
+++ b/src/cargo/core/package_id.rs
@@ -202,9 +202,10 @@ pub struct PackageIdStableHash<'a>(PackageId, &'a Path);
 
 impl<'a> Hash for PackageIdStableHash<'a> {
     fn hash<S: hash::Hasher>(&self, state: &mut S) {
-        self.0.inner.name.hash(state);
-        self.0.inner.version.hash(state);
-        self.0.inner.source_id.stable_hash(self.1, state);
+        println!("PackageIdStableHash:");
+        dbg!(&self.0.inner.name).hash(state);
+        dbg!(&self.0.inner.version).hash(state);
+        dbg!(&self.0.inner.source_id).stable_hash(dbg!(self.1), state);
     }
 }
 
